##### Заняты "академиками"

1. F# (Быков на F#)
1. Parallel model (Фаст)
1. Python (Бакаев)
1. Cи (Andrew)
1. Дмитрий Кузнецов (Стрёмное подмножество c#)
   * Async/await
   * Стрёмный LINQ синтаксис: `select ... from ... where ...`
   * лямбды с присваиваниями
   * Пользовательские классы можно не делать, один класс Program c кучей статических методов пойдет.
   * Стандартные типы данных, массивы
      * продемонстрировать на массивах ArrayTypeMismatchException
1. Pascal (Казанцев Антон)
   * функции/процедуры, присваивание, стандартные типы и типы-записи
   * динамическое выделение памяти не надо


##### Для "новеньких" (надо минимум 23 домашки)

1. OCaml + ADT
   * стандартный мини-язык, базовые типы, функции и рекурсия,
   * алгебраические типы как основной способ проектирования типов
   * можно поддержать пары, но можно и обойтись алгебраическим типом с одним конструктором
   * разумеется, объявления типов, паттерн-мэтчинг и типизапция
   * присваивание не надо
   * исключения не надо
1. OCaml + полиморфные вариантые типы
   * Как предыдущий проект "OCaml + ADT", только вместо алгебраических типов полиморфные варианты как они есть в OCaml
   * Объявления типов можно не делать
1. Haskell + ADT
   * Как "OCaml + ADT" только стратегия вычислений другая. Ну, и из-за этого примеры кода могут быть написаны по-другому.
1. OCaml + объекты
   * mini-ML с функциями, рекурсией
   * в OCaml есть интерсные объекты и их типизация, нужно поддержать объекты+методы+поля
   * (может быть классы и наследование тоже надо будет, но пока не уверен)
   * как тесты предлагаю реализовать некоторые струтуры данных как камлёвые объекты и посмотреть, что будет
1. OCaml + effects (2 человека)
   * супер-модное в наши дни движение в мире ФП
   * По сути, это исключения, но в момент обработки которых у нас есть функция, которой можно был передать значение, которое должно было бы быть вместо бросания исключение, и продолжить исполнение с места бросания исключения.
   * Туториал в контексте OCaml https://github.com/ocamllabs/ocaml-effects-tutorial
   * два человека только потому, что хочу чтобы задачу кто-то взял. А так это **очень** сильно напоминает задачи про delim/cc
1.
1. OCaml + GADT (2 человека)
   * OCaml где алгебраические типы заменены на обобщенные (generalized) алгебраические типы
   * Вывод/проверка типов там сложнее, чем для обычных алгебраических, поэтому два человека
   * [Умная сслыка, описывающая что примерно вас ждет](https://ocaml.org/releases/4.12/manual/gadts.html)
1.
1. OCaml, присваивание, именованые и опциональные аргументы
   + придется поддержать присваивание в замыканиях
   + а также учесть, что присваивание влияет на вывод типов
   + стандартные типы (числа, списки, option)
   + функции, рекурсия
1. SML + equality types + value restriction
   + Почти предыдущая задача, но проще
   + Немножко другой парсер, потому что SML немножко отличается
   + equality types:
      * в типах функций появляются типовые переменные с двумя апострофами, что означает, что туда можно подставлять только типы, на которых работает функция проверки на равенство (функции и вещественные числа нельзя сравнивать)
   + какая-то ссылка https://users.cs.fiu.edu/~smithg/cop4555/valrestr.html
1. OCaml с типизированными эффектами
   * https://www.janestreet.com/tech-talks/effective-programming
   * Идея заключается в том, что теперь мы будем перечислять в типе функции-стрелки эффекты, которые совершает функция
      * Обычная стрелка `->` делает что угодно
      * Длинная стрелка `-->` (или `-[]->`) -- это чистая функция: не присваиваний, ввода-вывода. Ничего не делает такого.
      * Над стрелкой можно перечислять, что она делает:
          * `-[IO]->` делает ввод-вывод
          * `-[exc Not_found]->` кидает исключение `Not_found`
          * `-['a]->` совершает какой-то эффект, но он не указан (полиморфизм)
      * Пример:

          ```
          val id : 'a --> 'a
          val print_int: int -[IO]-> unit

          let map : ('a -['e]-> 'b) --> 'a list -['e]-> 'b list = fun f xs ->
            match xs with
            | [] -> []
            | x::xs -> (f x) :: (map f xs)

          let _ : 'a list --> 'b list = map id
          let _ : int list -[IO]-> int list = map (fun n -> print_int n; n+1)
          ```

          Фунция `id` чистая, поэтому над стрелочкой ничего не написано

          Функция `print_int` совершает ввод-вывод, что указано в типе

          `List.map` полиморфна (как обычно) по типу элементу списка, но также полиморфная по типу эффекта переданной функции, что указано в стрелке, которая выдает результат. Первая стреклка в типе `map` чистая, так как при передаче аргументов ничего не вычисляется и эффектов не совершается. В `map id` не совешается эффектов, поэтому типовая переменная `'e` сунифицировалась с отсутсвием эффектов. Во втором примере из-за того, что переданная функция совершает ввод-вывод, система типов догадывается, что и вычисление `map` совершает ввод-вывод.

          Вы уже видели приписывание эффектов к функциям, а именно, приписывание бросаемых исключений в языке Java. Но так как там не было полиморфизма по этим "эффектам", то люди ненавидели эту штуку и поэтому, на сколько я знаю, в идеалогических наследниках Java этого нет.
   * Итого, надо реализовать miniML
      * Стандартные штуки: числа, строки, функции высшего порядка, пары, списки
      * C эффектами: присваивание, печать на консоль и try/catch/raise для пары захардкоженных в язык исключений
      * С системой типов в описанном выше смысле.
1. OCaml + implicits
   * В OCaml нет ad hoc полиморфизма (то, что вы знаете под термином overloading), поэтому многим хочется иметь в грядущей версии OCaml следующую штуку
      * в области видимости объявляется некоторое количество OCamlовских модулей
      * у функций могут появляться неявные аргументы (implicit), которые программист не передает явно руками
      * момент вызова функции компилятор ищет в области видимости подходящие по типу модули и подставляет и вместо неявных аргументов, если не найти -- ошибка, если больше 1го подходящего варианта -- тоже
1. Scala 3 + givens
   * как предыдущее, только вместо OCaml -- синтаксис Scala 3, вместо камлёвых модулей -- скальные объекты
1. Scheme + call/cc
   * относительно легко гуглящаяся особенность Scheme, человеку в том году удалось такую домашку сдать
   * call/cc
   * целые числа, рекурсия, списки, печать на консоль
   * присваивание не надо
   * quote/unquote
   * парсер очень простой
   * никаких статических типов, разумеется, нет
   * учитывая следующую задачу, получается в некотором смысле на двоих
1. Scheme + delim/cc
   * почти как предыдущая задача, только понятней
   * Кратко про delim/cc
      + есть две новые конструкции в языке: `reset (fun () -> M)` и `shift (fun k -> M)`
      + Пример: `reset (fun () -> 2 + 2 * shift (fun k -> k 20))`
         + Наличие одинокого `reset` не влияет на вычисление
         + Когда исполнение доходит до `shift`, то вместо аргумета подставляется функция, которая "зажата" между этим `shift` и ближайшим `reset`, В даннои случае это `fun y -> 2 + 2 * y`
         + таким образом, выражение выше вычисляется в 42
1. [OchaCaml](http://pllab.is.ocha.ac.jp/~asai/OchaCaml) (Caml Light + delim/cc) (2 человека)
   * стандартные типы (числа, списки), рекурсия
   * конструкции для отладочной печати
   * delim/сс
   * полиморфные типы для всего этого
     * типизация там необычная, надо по одной ссылке долистать до описания того, как это типизировать; по другой ссылке долистать до способов написания интерпретатора/компиляции
   * По сути эта задача и две предыдущие -- суть одно и то же
1.
1. мини-Coq с индуктиыными типами (2 человека)
   * похож на OCaml + ADT, но с некоторыми ограничениями
   * вводятся ограничения на объявления алгебраических  типов
      * чтобы избегать [парадокса Карри](https://counterexamples.org/currys-paradox.html)
      * иметь индуктивные типы, размер которых очевиден
   * объявляемые функции принимаются только если они завершаются
      * проверка делается на основе рассуждения "убывает по такому-то аргументу"
1.
1. Котлин, ООП и flow-sensitive typing
   * Стандартные типы данных, функции/методы, рекурсия и присваивание
   * ООП, наследование, вызов методов, изменение полей
   * Flow-sensitive typing: вывод того, может ли значение быть null или нет
      * Важный пример [отсюда](https://counterexamples.org/under-construction.html) должен работать
   * Давать на двоих не хочу, так как про всё это вам должны были рассказывать.
1. C++ и наследование
   * объявления функций, приваивание, рекурсия, стандартные типы, что-то для печати на консоль.
   * объекты, поля, методы
   * Наследование: public, private, protected, virtual
      * diamond problem
1. Java и generics (2 человека)
   * целые числа (`float` не нужно)
   * рекурсия
   * стандартные конструкции языка
     * `if`, `else`, `while` (взаимозаменяем с `do { ... } while`), `for`
     * `break` и `continue` оставить на потом
     * `switch` можно не реализовывать
     * исключения и тернарный оператор не нужны
   * присваивание
   * анонимные функции
   * классы (без `enum`), интерфейсы, наследование
   * поддержка многопоточности, нативного кода и сериализации не нужна
   * многофайловость не требуется
   * передача аргументов командной строки в `main` не нужна
   * в каком-то виде понадобится поддержка функций стандартной библиотеки
   * из методов класса `Object` достаточно поддерживать `hashCode`, `equals` и `toString`
   * реализовать более точное указание generic параметров (например, `<? super x>` и т.п.)
      * если заработает проверка типов (нужно отдельно реализовать тайпчекер) и интерпретатор на вот такой программе, то будет круто
      ```
      interface Z {}
      interface N<x> {}
      interface L<x> {}
      interface Qlr<x> {}
      interface Qrl<x> {}
      interface E<x> extends
         Qlr<N<?super Qr<?super E<?super E<?super x>>>>>,
         Qrl<N<?super Ql<?super E<?super E<?super x>>>>> {}
      interface Ql<x> extends
         L<N<?super Ql<?super L<?super N<?super x>>>>>,
         E<Qlr<?super N<?super x>>> {}
      interface Qr<x> extends
         L<N<?super Qr<?super L<?super N<?super x>>>>>,
         E<Qrl<?super N<?super x>>> {}
      class Main {
         L<?super N<?super
         L<?super N<?super
         L<?super N<?super
         E<?super E<?super Z>>>>>>>>
            doit( Qr<? super E<? super E<? super Z>>> v ) {
               return v;
         }
      }
      ```
1.
1. Refal 5
   * одскульный отечественный язык программирования, где последовательности можно мэтчить не только с начала, но и с конца
1. Ruby
    * Известный язык программирования, по типу Питона
    * стандартные конструкции, присваивание, рекурсивные функции, лямбды
    * объекты,
    * статической типизации там нет, потому и не надо
    * `method_missing` -- отличительная штука Ruby, где можно сказать, что делать, если метода нет
      * с помощью обработки отсутсвующего метода предлагаю сделать примеры про реализацию тестирования кода в стиле [rspec](https://github.com/rspec/rspec-core)
    * Прикольные штуки из [WAT talk](https://www.destroyallsoftware.com/talks/wat)
1. Javascript
   * Объекты, числа, строки, массивы
   * Типичное для Javascript прототипное наследование
   * Прикольные штуки из [WAT talk](https://www.destroyallsoftware.com/talks/wat)
1. Bash
1. [Cypher](https://neo4j.com/developer/cypher)
   * мини-язык для доступа к графовым базам данных
   * простой парсер, простой интепретатор, который исполняет запросоы на конкретных графах
   * оптимизации запросов я пока не придумывал, но я думаю, что их придумать не сложно
1. miniKanren -- относительно простой язык реляционного (логического) программирования. Может быть в разных синтаксисах, проще всего найти описание в синтаксисе Scheme в книжке Reasoned Schemer (ещё есть стартовый [туториал](https://io.livecode.ch/learn/webyrd/webmk)). Состоит из довольно малого количества понятий. Ниже кратко опишу в синтаксисе Scheme.
    * Логические переменные, им можно сопоставлять выражение с логическими переменными (или без) внутри и получать **подстановку**.
    * Goal (цель) -- то, что можно посчитать. По сути функция из стартовой подстановки в ленивую последовательность подстановок.
    * Примитив `(run number (vars) goal)` -- вычисляет goal, подставляя туда стартовую пустую подстановку; и  достает из результирующих подстановок (нужны первые `number` штук) посчитанные значения переменных верхнеуровневых `vars`
    * Унификация `(== expr expr)` -- позволяет получать знания о подстановках переменных.
    * Объявление новых логических переменных `fresh (vars) goal` для их использования. Например:

      ```
      > (run 1 (q) (fresh (x y z) (== x z) (== 3 y)))
      (_.0)
      ```
      Выдан один ответ, переменная `q` с номером 0 является свободной, потому что с ней никто не унифицировался

      ```
      > (run 1 (y)  (fresh (x z)   (== x z)    (== 3 y)))
      (3)
      ```
      Мы проунифицировали `y` и  3, что и видно в ответе.
    * Конъюнкция: если пишем `fresh (...) goal1 goal2 ...` то все цели неявно объединяются конъюнкцией. Конъюнкция `(conj l r)` является целью и вычисляется следующим образом:
        * Запускаемся на какой-то подстановке. Левая часть дает какой-то ответ (подстановку), и её и будем передавать в правый goal `r`. Там получатся какие-то ответы, их складываем в ответ. Затем делаем то же самое со вторым ответом из `l` и т.д. От перемены мест конъюнктов ответы не меняются, но может нарушиться завершаемость вычисления этих ответов!
    * delay (пауза) -- указание, что сейчас можно поиск в этой ветке приостановить и поискать в другой. Обычно вставляется внутрь конъюнкции и после fresh.
    * Дизъюнкция: `(conde (goal1 goal2 ...))` -- альтернатива, пытаемся искать ответ разными способами. Если вычисляем `goal` до конца -- будет поиск в глубину (плох тем, что если в одной ветке никогда не найдется ответ -- мы можем там зависнуть). Если делаем по одному шагу в каждом goal --- поиск в ширину (плох тем, что пространство поиска растёт очень быстро). В miniKanren принято делать interleaving search: вычисляем первый дизъюнкт до паузы, затему второй, 1й, 3й, 1й, 2й и т.д. Грубо говоря, первый работает в половине случаев, второй -- в четверти и т.д. Таким образом получается что-то среднее между в глубину и в ширину.
    * TODO: описать disequality constrains.
1. Ассемблер x86_64 --- очень простой язык и для парсинга, и для реализации интерпретатора. Халява.
    * Язык должен быть настоящим ассемблером, т.е. входные программы должны компилироваться соответствующим компилятором и выдавать ответ как в интерпретаторе
    * Примеры стоит взять из первой части книжки И.Жиркова "Low-level programming".
    * Чтобы задача не была чересчур простой, хочу также в ассемблере SIMD операции и тесты к ним (перемножение вектора/матрицы на вектор/матрицу)
1. C# c исключениями.
    * Стандартные конструкции языка.
    * Целые числа, строки, стандартные функции работы с ними.
    * Массивы и лямбды не надо.
    * try/catch/finally
    * Исключения
        + Пользователь может наследоваться от класса Exception и объявлять свои исключения без новых методов внутри. Получатся какие-то супер-сокращенные объекты с иерархией наследования высоты 2 и синтаксисом [на подобие record'ов](https://diary-of-programmer.blogspot.com/2020/11/finally-c-9-record-equivalent-of-scalas.html). Короче, полноценные объекты не надо.

        ```
        public class Person : Exception {
          public string FirstName {get; init;}
          public string LastName {get; init;}
        }
        var a = new Person { FirstName = "Michael", LastName = "Page" };
        ```
        + Исключения должны уметь выдавать backtrace c именами функий и позциями в файле, где они вызывались. С этим скорее всего придется запариться
        + Фильтры исключений, которые я просил в том году у Мирошникова -- не надо.
    * Какой-нибудь тайпчекер на случай, чтобы отфильтровывать бредовые программы
    * Какое-нибудь API для чтения/записи файлов, чтобы можно было содержательно протестировать finally
1. Объектно-ориентированый C# c классами, интерфейсами (Алимов)
    * Наследование классов и интерфейсов, без generics.
    * public/private/protected и override.
    * Стандартные конструкции языка + приведение типов объектов.
    * Целые числа, строки, стандартные функции работы с ними; массивы и лямбды не надо.
    * Что-нибудь для печатанья значений переменных в языке.
    * Какой-нибудь тайпчекер на случай, чтобы отфильтровывать бредовые программы.
    * [new методы](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/new-modifier)
        * Я слышал, что при их использовании вместе с интерфейсами, там возникает какая-то нетривиальная семантика. Надо будет разобраться. [Вот](https://gist.github.com/Kakadu/331354abae0269e6495bbb0af416853c) пример.

##### Определюсь/допишу потом если тем будет не хватать/или кому-то очень захочется/и не будет лениво их доформулировать

1. Pascal (записан за Казанцевым)
   + алгебраические типы данных [variant records](https://www.bestprog.net/en/2016/10/10/records/#q12) (пункт 12).
1. Go
1. Fortran?
1. Visual Basic.NET (клон C# с другим синтаксисом)
    * [На вики есть](https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Visual_Basic_.NET#Features_of_Visual_Basic_.NET_not_found_in_C#) список отличий. Если сесть и посмотреть, то наверняка можно придумать задачу.
1. F# + active patterns
1. C# c паттерн-мэтчингом
1. Какие-нибудь смарт-контракты
1. MSIL
1. Makefiles  -- может оказаться чересчур просто
1. С# с многофайловостью, [мультиметодами](https://en.wikipedia.org/wiki/Multiple_dispatch#C#) и экстеншинами
1. OCaml с первоклассными модулями
1. Aspectual Caml?
1. Aspect C# ?
1. C# c [Goto](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/goto) и ещё чем-нибудь
1. Scala где есть и аргументы call-by-value, и аргументы call-by-name. И ещё что-нибудь
1. Refinement types by [Ranjit Jhala](https://github.com/ranjitjhala/sprite-lang)


##### Прочие замечания

В общем и целом вы делаете парсер, интерпретатор + преобразования AST, набираете баллы. Они влияют на максимум оценки за экзамен. Планируется, что те, кто сделают интерпретатор смогут претендовать на оценку C, а также смогут легко добрать баллов до A.

Задачи не вполне равнозначные по сложности. В ближайшем будущем я планирую их побалансировать и давать за некоторые больше баллов. Точная разбалловку будет позже

Некоторые темы записаны на двоих. Это означает, что делаете в двоем, вместе, одно и то же. В конце я буду ожидать, что оба разбираются в коде и смогут объяснить, что там происходит.

Если у Вас есть предложения по добавлению других языков -- пишите.

У меня была идея давать задачи частично на двоих, а именно, первый пишет интерпретатор, второй -- компилятор в .NET, например. Но я подумал, что второкурсники не осилят этого.
